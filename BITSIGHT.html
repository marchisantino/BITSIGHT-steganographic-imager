<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>BITSIGHT</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --crt-glow: #33ff33;
            --crt-glow-dark: rgba(51, 255, 51, 0.2);
            --crt-text: #d1ffd1;
            --crt-bg: #0a0c0a;
            --crt-border: #1a4d1a;
            --font-main: 'VT323', monospace;
            --transition-speed: 0.2s;
        }

        @keyframes text-flicker {
            0% { text-shadow: 0 0 5px var(--crt-glow), 0 0 10px var(--crt-glow-dark); }
            49% { text-shadow: 0 0 5px var(--crt-glow), 0 0 10px var(--crt-glow-dark); }
            50% { text-shadow: 0 0 7px var(--crt-glow), 0 0 15px var(--crt-glow-dark), 0 0 2px white; }
            100% { text-shadow: 0 0 5px var(--crt-glow), 0 0 10px var(--crt-glow-dark); }
        }

        @keyframes crt-flicker {
            0% { opacity: 0.96; }
            50% { opacity: 1; }
            100% { opacity: 0.96; }
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-main);
            background-color: #000;
            color: var(--crt-text);
            font-size: 20px;
            text-transform: uppercase;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        .crt-screen {
            background: var(--crt-bg);
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            z-index: 90;
        }

        .crt-screen::after {
            content: " ";
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 4px, 3px 100%;
            pointer-events: none;
        }

        .container {
            width: 100%;
            max-width: 1800px;
            margin: 0 auto;
            padding: 2rem;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        h1 {
            text-align: center;
            font-size: 3.5rem;
            color: var(--crt-glow);
            animation: text-flicker 2s infinite;
            margin-bottom: 2rem;
            letter-spacing: 4px;
            flex-shrink: 0;
            will-change: text-shadow;
        }

        h1::after {
            content: '_';
            animation: blink 0.7s infinite;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        .main-content {
            display: flex;
            gap: 2rem;
            flex-grow: 1;
            overflow: hidden;
        }

        .controls {
            border: 2px solid var(--crt-border);
            padding: 1.5rem;
            flex: 0 0 420px;
            background-color: rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 2rem;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            animation: crt-flicker 0.1s infinite;
        }

        .controls::-webkit-scrollbar {
            display: none;
        }

        .prompt::before {
            content: '>';
            margin-right: 1ch;
            color: var(--crt-glow);
        }

        #imageInput {
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            position: absolute;
            z-index: -1;
        }

        .file-upload-label {
            color: var(--crt-glow);
            cursor: pointer;
            border: 1px dashed var(--crt-border);
            padding: 1.5rem;
            text-align: center;
            transition: var(--transition-speed);
            width: 100%;
            display: block;
        }
        .file-upload-label:hover {
            background: var(--crt-glow-dark);
            border-color: var(--crt-glow);
        }

        #imagePreview {
            width: 100%;
            max-width: 300px;
            max-height: 200px;
            margin: 1rem auto 0;
            display: none;
            border: 2px solid var(--crt-border);
            image-rendering: pixelated;
            object-fit: contain;
        }

        .bit-selector {
            display: grid;
            grid-template-columns: 3ch 1fr;
            align-items: center;
            gap: 1rem;
        }

        .bit-selector label {
            font-size: 1.5rem;
            color: var(--crt-text);
        }

        .bits {
            display: flex;
            gap: 6px;
        }

        .bit {
            width: 35px;
            height: 35px;
            border: 2px solid var(--crt-border);
            background-color: #222;
            color: var(--crt-text);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: all var(--transition-speed) ease;
        }

        .bit:hover { color: var(--crt-glow); }
        .bit:active { transform: translateY(1px); }

        .bit.active {
            background-color: var(--crt-glow);
            color: var(--crt-bg);
            border-color: var(--crt-glow);
        }

        #toggleBtn {
            -webkit-appearance: none; appearance: none;
            width: 50px; height: 26px;
            border: 2px solid var(--crt-border);
            background: #222;
            position: relative; cursor: pointer;
        }
        #toggleBtn::before {
            content: ''; position: absolute;
            width: 18px; height: 18px;
            background: var(--crt-text);
            top: 2px; left: 2px;
            transition: var(--transition-speed);
        }
        #toggleBtn:hover::before { background: var(--crt-glow); }
        #toggleBtn.heatmap { border-color: var(--crt-glow); }
        #toggleBtn.heatmap::before { transform: translateX(24px); }
        
        .mode-status::before { content: '[HEATMAP]'; color: var(--crt-glow); }
        .binary + .mode-status::before { content: '[BINARY]'; color: var(--crt-text); }

        .binary-ops {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .binary-op {
            padding: 0.5rem;
            border: 1px solid var(--crt-border);
            background: #222;
            color: var(--crt-text);
            cursor: pointer;
            transition: var(--transition-speed);
            text-align: center;
        }

        .binary-op:hover {
            background: var(--crt-glow-dark);
        }

        .binary-op.active {
            background: var(--crt-glow);
            color: var(--crt-bg);
            border-color: var(--crt-glow);
        }

        p {
            font-size: 1rem;
            color: var(--crt-text);
            line-height: 1.5;
            background: var(--crt-border);
            padding: 1rem;
        }
        p::before { content: '/* '; }
        p::after { content: ' */'; }
        
        .canvas-container {
            flex-grow: 1;
            border: 2px solid var(--crt-border);
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            background: repeating-linear-gradient(var(--crt-bg), var(--crt-bg) 1px, #000 1px, #000 2px);
            min-height: 0;
            position: relative;
            overflow: hidden;
        }

        #stegCanvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background-color: transparent;
            z-index: 99;
            position: absolute;
        }

        .canvas-container:not(:has(canvas[width])) {
            border-color: transparent;
            background: transparent;
        }

        .zoom-info {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            background: rgba(10, 12, 10, 0.7);
            border: 1px solid var(--crt-border);
            color: var(--crt-text);
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            z-index: 100;
            opacity: 1;
            pointer-events: none;
        }

        .zoom-indicator {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: var(--crt-bg);
            border: 1px solid var(--crt-border);
            color: var(--crt-text);
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            z-index: 100;
        }
    </style>
</head>
<body>

<div class="crt-screen">
    <div class="container">
        <h1>BITSIGHT</h1>

        <div class="main-content">
            <div class="controls">
                <div>
                    <div class="prompt">LOAD_IMAGE</div>
                    <label for="imageInput" class="file-upload-label">
                        [SELECT FILE...]
                    </label>
                    <input type="file" id="imageInput" accept="image/png, image/jpeg">
                    <img id="imagePreview" src="#" alt="Image Preview">
                </div>

                <div>
                    <div class="prompt">SET_BIT_PLANES</div>
                    <div id="channelControls" style="display: flex; flex-direction: column; gap: 1rem; margin-top: 1rem;">
                    </div>
                </div>

                <div>
                    <div class="prompt">SET_RENDER_MODE</div>
                    <div style="display: flex; align-items: center; gap: 1ch; margin-top: 1rem;">
                        <button id="toggleBtn" class="toggle-btn heatmap"></button>
                        <span class="mode-status"></span>
                    </div>
                    
                    <div class="binary-ops" id="binaryOps" style="display: none;">
                        <div class="binary-op active" data-op="or">OR</div>
                        <div class="binary-op" data-op="and">AND</div>
                        <div class="binary-op" data-op="xnor">XNOR</div>
                        <div class="binary-op" data-op="majority">MAJORITY</div>
                        <div class="binary-op" data-op="minority">MINORITY</div>
                    </div>
                </div>
                
                <p>Look at those JPEG artifacts.. Pure art.</p>

            </div>

            <div class="canvas-container" id="canvasContainer">
                <canvas id="stegCanvas"></canvas>
                <div class="zoom-indicator" id="zoomIndicator">0%</div>
                <div class="zoom-info">DOUBLE CLICK TO RESET</div>
            </div>
        </div>
    </div>
</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const imageInput = document.getElementById('imageInput');
            const imagePreview = document.getElementById('imagePreview');
            const stegCanvas = document.getElementById('stegCanvas');
            const channelControls = document.getElementById('channelControls');
            const toggleBtn = document.getElementById('toggleBtn');
            const binaryOps = document.getElementById('binaryOps');
            const canvasContainer = document.getElementById('canvasContainer');
            const zoomIndicator = document.getElementById('zoomIndicator');

            const stegCtx = stegCanvas.getContext('2d', { willReadFrequently: true });
            let originalImageData = null;

            const channels = ['R', 'G', 'B', 'A'];
            const activeBits = {};
            let isHeatmapMode = true;
            let currentBinaryOp = 'or';
            
            let zoomPercent = 0;
            let panX = 0;
            let panY = 0;
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let dragStartPanX = 0;
            let dragStartPanY = 0;

            let baseScale = 1;

            function setupControls() {
                channelControls.innerHTML = '';
                channels.forEach(channel => {
                    const div = document.createElement('div');
                    div.className = 'bit-selector';
                    div.innerHTML = `<label>${channel}:</label><div class="bits" id="bits-${channel}"></div>`;
                    channelControls.appendChild(div);

                    const bitsContainer = document.getElementById(`bits-${channel}`);
                    for (let i = 7; i >= 0; i--) {
                        const bitDiv = document.createElement('div');
                        bitDiv.className = 'bit';
                        bitDiv.textContent = i;
                        bitDiv.dataset.channel = channel;
                        bitDiv.dataset.bit = i;
                        bitsContainer.appendChild(bitDiv);
                    }
                    activeBits[channel] = [];
                });
            }

            function calculateBaseScale() {
                if (!originalImageData) return 1;
                
                const containerRect = canvasContainer.getBoundingClientRect();
                const containerWidth = containerRect.width - 32;
                const containerHeight = containerRect.height - 32;
                
                const imageWidth = stegCanvas.width;
                const imageHeight = stegCanvas.height;
                
                const scaleX = containerWidth / imageWidth;
                const scaleY = containerHeight / imageHeight;
                
                return Math.min(scaleX, scaleY, 1);
            }

            function getActualScale() {
                if (zoomPercent === 0) {
                    return baseScale;
                }
                
                const targetScale = 3; 
                return baseScale + (zoomPercent / 300) * (targetScale - baseScale);
            }

            function updateCanvasPosition() {
                if (!originalImageData) return;
                
                const scale = getActualScale();
                
                const scaledWidth = stegCanvas.width * scale;
                const scaledHeight = stegCanvas.height * scale;
                
                const containerRect = canvasContainer.getBoundingClientRect();
                const centerX = containerRect.width / 2;
                const centerY = containerRect.height / 2;
                
                const left = centerX - (scaledWidth / 2) + panX;
                const top = centerY - (scaledHeight / 2) + panY;
                
                stegCanvas.style.width = scaledWidth + 'px';
                stegCanvas.style.height = scaledHeight + 'px';
                stegCanvas.style.left = left + 'px';
                stegCanvas.style.top = top + 'px';
                
                updateZoomIndicator();
            }

            function setupZoomAndPan() {
               
                canvasContainer.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    const delta = -Math.sign(e.deltaY);
                    const zoomStep = 10; 
                    
                    const oldZoom = zoomPercent;
                    zoomPercent = Math.max(0, Math.min(300, zoomPercent + delta * zoomStep));
                    
                    if (oldZoom !== zoomPercent) {
                        
                        const rect = canvasContainer.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left;
                        const mouseY = e.clientY - rect.top;
                        
                        const oldScale = baseScale * (1 + (oldZoom / 100) * 2);
                        const newScale = baseScale * (1 + (zoomPercent / 100) * 2);
                        
                        const scaledWidth = stegCanvas.width * oldScale;
                        const scaledHeight = stegCanvas.height * oldScale;
                        
                        const centerX = rect.width / 2;
                        const centerY = rect.height / 2;
                        
                        const oldLeft = centerX - (scaledWidth / 2) + panX;
                        const oldTop = centerY - (scaledHeight / 2) + panY;
                      
                        const imageX = (mouseX - oldLeft) / oldScale;
                        const imageY = (mouseY - oldTop) / oldScale;
                        
                        const newScaledWidth = stegCanvas.width * newScale;
                        const newScaledHeight = stegCanvas.height * newScale;
                        
                        const newLeft = centerX - (newScaledWidth / 2) + panX;
                        const newTop = centerY - (newScaledHeight / 2) + panY;
                        
                        const newMouseX = newLeft + imageX * newScale;
                        const newMouseY = newTop + imageY * newScale;
                        
                        panX += mouseX - newMouseX;
                        panY += mouseY - newMouseY;
                        
                        updateCanvasPosition();
                    }
                });
                
                canvasContainer.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        isDragging = true;
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        dragStartPanX = panX;
                        dragStartPanY = panY;
                        canvasContainer.style.cursor = 'grabbing';
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - dragStartX;
                        const deltaY = e.clientY - dragStartY;
                        
                        panX = dragStartPanX + deltaX;
                        panY = dragStartPanY + deltaY;
                        
                        updateCanvasPosition();
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        canvasContainer.style.cursor = 'grab';
                    }
                });
                
                canvasContainer.addEventListener('dblclick', () => {
                    resetZoom();
                });
            }
            
            function resetZoom() {
                zoomPercent = 0;
                panX = 0;
                panY = 0;
                updateCanvasPosition();
            }
            
            function updateZoomIndicator() {
                zoomIndicator.textContent = `${zoomPercent}%`;
            }

            channelControls.addEventListener('click', (e) => {
                const target = e.target.closest('.bit');
                if (!target || !originalImageData) return;

                target.classList.toggle('active');
                const channel = target.dataset.channel;
                const bit = parseInt(target.dataset.bit, 10);

                const index = activeBits[channel].indexOf(bit);
                if (index > -1) {
                    activeBits[channel].splice(index, 1);
                } else {
                    activeBits[channel].push(bit);
                }
                visualizeSteganography();
            });

            binaryOps.addEventListener('click', (e) => {
                const target = e.target.closest('.binary-op');
                if (!target) return;

                document.querySelectorAll('.binary-op').forEach(op => op.classList.remove('active'));
                target.classList.add('active');
                currentBinaryOp = target.dataset.op;
                visualizeSteganography();
            });

            toggleBtn.addEventListener('click', () => {
                isHeatmapMode = !isHeatmapMode;
                if (isHeatmapMode) {
                    toggleBtn.classList.remove('binary');
                    toggleBtn.classList.add('heatmap');
                    binaryOps.style.display = 'none';
                } else {
                    toggleBtn.classList.remove('heatmap');
                    toggleBtn.classList.add('binary');
                    binaryOps.style.display = 'flex';
                }
                visualizeSteganography();
            });

            imageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        stegCanvas.width = img.width;
                        stegCanvas.height = img.height;

                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = img.width;
                        tempCanvas.height = img.height;
                        tempCtx.drawImage(img, 0, 0);

                        originalImageData = tempCtx.getImageData(0, 0, img.width, img.height);

                        imagePreview.src = event.target.result;
                        imagePreview.style.display = 'block';

                        baseScale = calculateBaseScale();
                        resetZoom();
                        visualizeSteganography();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });

            function visualizeSteganography() {
                if (!originalImageData) {
                    stegCanvas.width = 0;
                    stegCanvas.height = 0;
                    return;
                }

                const imageData = originalImageData.data;
                const stegData = stegCtx.createImageData(stegCanvas.width, stegCanvas.height);
                const stegPixels = stegData.data;

                const selectedBits = [];
                for (const channel in activeBits) {
                    activeBits[channel].forEach(bitPos => {
                        const channelIndex = channels.indexOf(channel);
                        selectedBits.push({ channelIndex, bitPos });
                    });
                }
                
                if (selectedBits.length === 0) {
                    stegCtx.clearRect(0, 0, stegCanvas.width, stegCanvas.height);
                    updateCanvasPosition();
                    return;
                }

                if (isHeatmapMode) {
                    let maxValue = 0;
                    selectedBits.forEach(bit => maxValue += Math.pow(2, bit.bitPos));
                    if (maxValue === 0) {
                         stegCtx.clearRect(0, 0, stegCanvas.width, stegCanvas.height);
                         updateCanvasPosition();
                         return;
                    }
                    for (let i = 0; i < imageData.length / 4; i++) {
                        const pixelIndex = i * 4;
                        let pixelValue = 0;

                        for (const { channelIndex, bitPos } of selectedBits) {
                            const channelValue = imageData[pixelIndex + channelIndex];
                            if (((channelValue >> bitPos) & 1) === 1) {
                                pixelValue += Math.pow(2, bitPos);
                            }
                        }

                        const normalizedValue = (pixelValue / maxValue) * 255;
                        const gray = Math.round(normalizedValue);

                        stegPixels[pixelIndex] = gray;
                        stegPixels[pixelIndex + 1] = gray;
                        stegPixels[pixelIndex + 2] = gray;
                        stegPixels[pixelIndex + 3] = 255;
                    }
                } else {
                    for (let i = 0; i < imageData.length / 4; i++) {
                        const pixelIndex = i * 4;
                        let result = false;

                        const bitValues = [];
                        for (const { channelIndex, bitPos } of selectedBits) {
                            const channelValue = imageData[pixelIndex + channelIndex];
                            bitValues.push(((channelValue >> bitPos) & 1) === 1);
                        }

                        switch (currentBinaryOp) {
                            case 'or':
                                result = bitValues.some(v => v);
                                break;
                            case 'and':
                                result = bitValues.every(v => v);
                                break;
                            case 'xnor':
                                result = bitValues.every(v => v) || bitValues.every(v => !v);
                                break;
                            case 'majority':
                                const trueCount = bitValues.filter(v => v).length;
                                result = trueCount > bitValues.length / 2;
                                break;
                            case 'minority':
                                const falseCount = bitValues.filter(v => !v).length;
                                result = falseCount > bitValues.length / 2;
                                break;
                        }

                        if (result) {
                            stegPixels[pixelIndex] = 255;
                            stegPixels[pixelIndex + 1] = 255;
                            stegPixels[pixelIndex + 2] = 255;
                            stegPixels[pixelIndex + 3] = 255;
                        } else {
                            stegPixels[pixelIndex] = 0;
                            stegPixels[pixelIndex + 1] = 0;
                            stegPixels[pixelIndex + 2] = 0;
                            stegPixels[pixelIndex + 3] = 255;
                        }
                    }
                }
                stegCtx.putImageData(stegData, 0, 0);
                updateCanvasPosition();
            }

            setupControls();
            setupZoomAndPan();
            canvasContainer.style.cursor = 'grab';
        });
    </script>
</body>
</html>